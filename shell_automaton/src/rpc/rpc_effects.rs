// Copyright (c) SimpleStaking, Viable Systems and Tezedge Contributors
// SPDX-License-Identifier: MIT

use crate::service::rpc_service::{RpcRequest, RpcRequestStream};
use crate::service::{RpcService, Service};
use crate::mempool::{
    MempoolOperationInjectAction, MempoolAskCurrentHeadAction, MempoolRegisterOperationsStreamAction,
    MempoolRemoveAppliedOperationsAction, MempoolGetPendingOperationsAction,
};
use crate::{Action, ActionWithMeta, Store};

pub fn rpc_effects<S: Service>(store: &mut Store<S>, action: &ActionWithMeta) {
    match &action.action {
        Action::WakeupEvent(_) => {
            while let Ok((msg, rpc_id)) = store.service().rpc().try_recv_stream() {
                match msg {
                    RpcRequestStream::GetOperations { applied, refused, branch_delayed, branch_refused } => {
                        store.dispatch(MempoolRegisterOperationsStreamAction {
                            rpc_id,
                            applied,
                            refused,
                            branch_delayed,
                            branch_refused,
                        });
                    }
                }
            }
            while let Ok((msg, rpc_id)) = store.service().rpc().try_recv() {
                match msg {
                    RpcRequest::GetCurrentGlobalState { channel } => {
                        let _ = channel.send(store.state.get().clone());
                    }
                    RpcRequest::InjectOperation { operation, operation_hash } => {
                        store.dispatch(
                            MempoolOperationInjectAction {
                                operation,
                                operation_hash,
                                rpc_id,
                            },
                        );
                    }
                    RpcRequest::RequestCurrentHeadFromConnectedPeers => {
                        store.dispatch(MempoolAskCurrentHeadAction {});
                    }
                    RpcRequest::RemoveOperations { operation_hashes } => {
                        store.dispatch(MempoolRemoveAppliedOperationsAction { operation_hashes });
                    }
                    RpcRequest::MempoolStatus => {
                        match &store.state().mempool.running_since {
                            None => store.service().rpc().respond(rpc_id, serde_json::Value::Null),
                            Some(()) => store.service().rpc().respond(rpc_id, serde_json::Value::String("".to_string())),
                        }
                    }
                    RpcRequest::GetPendingOperations => {
                        store.dispatch(MempoolGetPendingOperationsAction { rpc_id });
                    }
                }
            }
        }
        _ => {}
    }
}
