// Copyright (c) SimpleStaking and Tezedge Contributors
// SPDX-License-Identifier: MIT

use std::io;
use std::path::{Path, PathBuf};
use std::process::{Child, Command};
use std::time::Duration;

use failure::Fail;
use nix::sys::signal;
use nix::sys::signal::Signal;
use nix::unistd::Pid;
use slog::Level;
use wait_timeout::ChildExt;

use crate::ProtocolEndpointConfiguration;

/// Errors generated by `protocol_runner`.
#[derive(Fail, Debug)]
pub enum ProtocolRunnerError {
    #[fail(
        display = "Failed to spawn tezos protocol wrapper sub-process: {}",
        reason
    )]
    SpawnError { reason: io::Error },
    #[fail(
        display = "Failed to terminate/kill tezos protocol wrapper sub-process, reason: {}",
        reason
    )]
    TerminateError { reason: String },
}

impl slog::Value for ProtocolRunnerError {
    fn serialize(
        &self,
        _record: &slog::Record,
        key: slog::Key,
        serializer: &mut dyn slog::Serializer,
    ) -> slog::Result {
        serializer.emit_arguments(key, &format_args!("{}", self))
    }
}

/// Control protocol runner sub-process.
#[derive(Clone)]
pub struct ExecutableProtocolRunner {
    sock_cmd_path: PathBuf,
    sock_evt_path: Option<PathBuf>,
    executable_path: PathBuf,
    endpoint_name: String,
    log_level: Level,
}

impl ExecutableProtocolRunner {
    /// Send SIGINT signal to the sub-process, which is cheking for this ctrl-c signal and shuts down gracefully if recieved
    fn terminate_or_kill(process: &mut Child, reason: String) -> Result<(), ProtocolRunnerError> {
        // try to send SIGINT (ctrl-c)
        match signal::kill(Pid::from_raw(process.id() as i32), Signal::SIGINT) {
            Ok(_) => Ok(()),
            Err(sigint_error) => {
                // (fallback) if SIGINT failed, we just kill process
                match process.kill() {
                    Ok(_) => Ok(()),
                    Err(kill_error) => Err(ProtocolRunnerError::TerminateError {
                        reason: format!(
                            "Reason for termination: {}, sigint_error: {}, kill_error: {}",
                            reason, sigint_error, kill_error
                        ),
                    }),
                }
            }
        }
    }
}

impl ProtocolRunner for ExecutableProtocolRunner {
    type Subprocess = Child;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration = Duration::from_secs(10);

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        sock_evt_path: Option<PathBuf>,
        endpoint_name: String,
    ) -> Self {
        ExecutableProtocolRunner {
            sock_cmd_path: sock_cmd_path.to_path_buf(),
            sock_evt_path,
            executable_path: configuration.executable_path().clone(),
            endpoint_name,
            log_level: configuration.log_level().clone(),
        }
    }

    fn spawn(&self) -> Result<Self::Subprocess, ProtocolRunnerError> {
        let process = match &self.sock_evt_path {
            Some(sep) => Command::new(&self.executable_path)
                .arg("--sock-cmd")
                .arg(&self.sock_cmd_path)
                .arg("--sock-evt")
                .arg(&sep)
                .arg("--endpoint")
                .arg(&self.endpoint_name)
                .arg("--log-level")
                .arg(&self.log_level.as_str().to_lowercase())
                .spawn()
                .map_err(|err| ProtocolRunnerError::SpawnError { reason: err })?,
            None => Command::new(&self.executable_path)
                .arg("--sock-cmd")
                .arg(&self.sock_cmd_path)
                .arg("--endpoint")
                .arg(&self.endpoint_name)
                .arg("--log-level")
                .arg(&self.log_level.as_str().to_lowercase())
                .spawn()
                .map_err(|err| ProtocolRunnerError::SpawnError { reason: err })?,
        };
        Ok(process)
    }

    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError> {
        match process.wait_timeout(wait_timeout) {
            Ok(Some(_exit_status)) => {
                // process exited, so we are ok
                Ok(())
            }
            Ok(None) => Self::terminate_or_kill(process, "wait timeout exceeded".to_string()),
            Err(e) => Self::terminate_or_kill(process, format!("{}", e)),
        }
    }

    fn is_running(process: &mut Self::Subprocess) -> bool {
        matches!(process.try_wait(), Ok(None))
    }
}

pub trait ProtocolRunner: Clone + Send + Sync {
    type Subprocess: Send;
    const PROCESS_TERMINATE_WAIT_TIMEOUT: Duration;

    fn new(
        configuration: ProtocolEndpointConfiguration,
        sock_cmd_path: &Path,
        sock_evt_path: Option<PathBuf>,
        endpoint_name: String,
    ) -> Self;

    fn spawn(&self) -> Result<Self::Subprocess, ProtocolRunnerError>;

    /// Give [`wait_timeout`] time to stop process, and after that if tries to terminate/kill it
    fn wait_and_terminate_ref(
        process: &mut Self::Subprocess,
        wait_timeout: Duration,
    ) -> Result<(), ProtocolRunnerError>;

    /// Checks if process is running
    fn is_running(process: &mut Self::Subprocess) -> bool;
}
