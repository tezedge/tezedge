// Copyright (c) SimpleStaking and Tezedge Contributors
// SPDX-License-Identifier: MIT

//! Separate Tezos protocol runner, as we used OCaml protocol more and more, we noticed increasing
//! problems, from panics to high memory usage, for better stability, we separated protocol into
//! self-contained process communicating through Unix Socket.

use std::thread;
use std::time::Duration;

use clap::{App, Arg};
use slog::*;

use tezos_context::channel;
use tezos_interop::runtime;

fn create_logger(log_level: Level) -> Logger {
    let drain = slog_async::Async::new(
        slog_term::FullFormat::new(
            slog_term::TermDecorator::new().build()
        ).build().fuse()
    ).build().filter_level(log_level).fuse();

    Logger::root(drain, slog::o!())
}

fn main() {
    let matches = App::new("Protocol Runner")
        .version("1.0")
        .author("Tomas Sedlak <tomas.sedlak@simplestaking.com>")
        .about("Tezos Protocol Runner")
        .arg(Arg::with_name("sock-cmd")
            .short("c")
            .long("sock-cmd")
            .value_name("path")
            .help("Path to a command socket")
            .takes_value(true)
            .empty_values(false)
            .required(true))
        .arg(Arg::with_name("sock-evt")
            .short("e")
            .long("sock-evt")
            .value_name("path")
            .help("Path to an event socket (not required)")
            .takes_value(true)
            .empty_values(false)
            .required(false))
        .arg(Arg::with_name("endpoint")
            .long("endpoint")
            .value_name("STRING")
            .help("Name of the endpoint, which spawned runner")
            .takes_value(true)
            .empty_values(false)
            .required(true))
        .arg(Arg::with_name("log-level")
            .long("log-level")
            .takes_value(true)
            .value_name("LEVEL")
            .possible_values(&["critical", "error", "warn", "info", "debug", "trace"])
            .help("Set log level"))
        .get_matches();

    let cmd_socket_path = matches.value_of("sock-cmd").expect("Missing sock-cmd value");
    let evt_socket_path = matches.value_of("sock-evt");
    let endpoint_name = matches.value_of("endpoint").expect("Missing endpoint value").to_string();
    let log_level = matches.value_of("log-level")
        .unwrap_or("info")
        .parse::<slog::Level>()
        .expect("Was expecting one value from slog::Level");

    let log = create_logger(log_level);

    {
        let log = log.clone();
        let endpoint_name = endpoint_name.clone();
        ctrlc::set_handler(move || {
            // do nothing and wait for parent process to send termination command
            debug!(log, "Shutting down ocaml runtime"; "endpoint" => &endpoint_name);
            runtime::shutdown();
            debug!(log, "Ocaml runtime shutdown complete"; "endpoint" => &endpoint_name);
        }).expect("Error setting Ctrl-C handler");
    }

    // Spawn a new event processing thread (if condigured evt_socket_path).
    // Events are generated by an OCaml code and are pushed into a shared channel from which protocol_runner
    // is reading them and then sends them to the Rust node via IPC channel.
    let event_thread = match evt_socket_path {
        Some(evt_socket_path) => Some(
            {
                let evt_socket_path = evt_socket_path.to_string();
                let log = log.clone();
                let endpoint_name = endpoint_name.clone();
                channel::enable_context_channel();
                thread::spawn(move || {
                    for _ in 0..5 {
                        match tezos_wrapper::service::process_protocol_events(&evt_socket_path) {
                            Ok(()) => break,
                            Err(err) => {
                                warn!(log, "Error while processing protocol events"; "endpoint" => &endpoint_name, "reason" => format!("{:?}", err));
                                thread::sleep(Duration::from_secs(1));
                            }
                        }
                    }
                })
            }
        ),
        None => None
    };

    // Process commands from from the Rust node. Most commands are instructions for the Tezos protocol
    if let Err(err) = tezos_wrapper::service::process_protocol_commands::<crate::tezos::NativeTezosLib, _>(cmd_socket_path) {
        error!(log, "Error while processing protocol commands"; "endpoint" => &endpoint_name, "reason" => format!("{:?}", err));
    }

    if let Some(event_thread) = event_thread {
        event_thread.join().expect("Failed to join event thread");
    }
}

mod tezos {
    use crypto::hash::{ChainId, ContextHash, ProtocolHash};
    use tezos_api::ffi::{ApplyBlockError, ApplyBlockResponse, CommitGenesisResult, GenesisChain, GetDataError, InitProtocolContextResult, PatchContext, ProtocolOverrides, TezosGenerateIdentityError, TezosRuntimeConfiguration, TezosRuntimeConfigurationError, TezosStorageInitError};
    use tezos_api::identity::Identity;
    use tezos_client::client::{apply_block, change_runtime_configuration, generate_identity, genesis_result_data, init_protocol_context};
    use tezos_messages::p2p::encoding::prelude::*;
    use tezos_wrapper::protocol::ProtocolApi;

    pub struct NativeTezosLib;

    impl ProtocolApi for NativeTezosLib {
        fn apply_block(chain_id: &ChainId, block_header: &BlockHeader, predecessor_block_header: &BlockHeader, operations: &Vec<Option<OperationsForBlocksMessage>>, max_operations_ttl: u16) -> Result<ApplyBlockResponse, ApplyBlockError> {
            apply_block(chain_id, block_header, predecessor_block_header, operations, max_operations_ttl)
        }

        fn change_runtime_configuration(settings: TezosRuntimeConfiguration) -> Result<(), TezosRuntimeConfigurationError> {
            change_runtime_configuration(settings)
        }

        fn init_protocol_context(
            storage_data_dir: String,
            genesis: GenesisChain,
            protocol_overrides: ProtocolOverrides,
            commit_genesis: bool,
            enable_testchain: bool,
            readonly: bool,
            patch_context: Option<PatchContext>) -> Result<InitProtocolContextResult, TezosStorageInitError> {
            init_protocol_context(storage_data_dir, genesis, protocol_overrides, commit_genesis, enable_testchain, readonly, patch_context)
        }

        fn genesis_result_data(
            genesis_context_hash: &ContextHash,
            chain_id: &ChainId,
            genesis_protocol_hash: &ProtocolHash,
            genesis_max_operations_ttl: u16) -> Result<CommitGenesisResult, GetDataError> {
            genesis_result_data(genesis_context_hash, chain_id, genesis_protocol_hash, genesis_max_operations_ttl)
        }

        fn generate_identity(expected_pow: f64) -> Result<Identity, TezosGenerateIdentityError> {
            generate_identity(expected_pow)
        }
    }
}